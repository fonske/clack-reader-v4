# Basics
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -100
    then:
      - script.execute: on_boot

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  actions:
    - action: water_meter_value
      variables:
        meter_value: float
      then:
        - lambda: |-
            id(totalWaterUsage) = float(meter_value);
        - component.update: clack_watermeter_total
        - pulse_meter.set_total_pulses:
            id: clack_flow_rate
            value: !lambda |-
              return id(totalWaterUsage) * id(pulse_per_liter);

    - action: last_distance_value #set last measured salt distance to any value in cm.
      variables:
        new_distance_value: float
      then:
        - lambda: |-
            id(last_distance) = float(new_distance_value);
        - component.update: clack_distance

globals:
  - id: totalWaterUsage
    type: float
    restore_value: yes
    initial_value: '0.0'

  # Clack DV flowmeter 28.60  / Clack WS1: 16.30 / (to be checked)
  - id: pulse_per_liter
    type: float
    restore_value: yes
    initial_value: '28.60'

  # Define a global variable for the chlorinator delay duration in minutes
  - id: duration
    type: int
    restore_value: yes
    initial_value: '15'

  # Define a global variable for the leakage delay duration in minutes
  - id: duration_leakage
    type: int
    restore_value: yes
    initial_value: '30'

  # Define a global variable for the water flow timeout in seconds
  - id: duration_water_flow_timeout
    type: float
    restore_value: yes
    initial_value: '6.5'

  # Define a global variable for last regeneration time
  - id: cycle_step
    type: std::string
    restore_value: yes
    initial_value: '"Idle"'

  # Define a global variable for last regeneration time
  - id: regen_last
    type: int
    restore_value: yes
    initial_value: '0'

  # Define a global variable for resinclean time
  - id: resinclean_last
    type: int
    restore_value: yes
    initial_value: '0'

  # Define a global variable for saltfill_last time
  - id: saltfill_last
    type: int
    restore_value: yes
    initial_value: '0'

  # Define a global variable for fill_last datetime
  # Deprecated in favour of the new "saltfill_last" global variable
  - id: fill_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

  # Define a global variable to store last value of the distance
  - id: last_distance
    type: float
    restore_value: yes
    initial_value: '0.0'

  # Define a global variable that blocks a new reg cycle
  - id: wait_on_delay
    type: bool
    restore_value: yes
    initial_value: 'false'

  # Define a global variable that blocks a new reg cycle
  - id: water_meter_freeze
    type: bool
    restore_value: yes
    initial_value: 'false'

  # Define a global variable that shows motor run
  - id: motor_run
    type: bool
    restore_value: yes
    initial_value: 'false'

  # cycle timer
  - id: start_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time
    type: int
    restore_value: yes
    initial_value: '0'

  # cycle timer total
  - id: start_time_total
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time_total
    type: int
    restore_value: yes
    initial_value: '0'

  ### record last settings during regen.
  # Deprecated in favour of the new save_total_operation_time global variable
  - id: save_total_time_used
    type: std::string
    restore_value: yes
    initial_value: '"Unknown"'

  - id: save_total_operation_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_total_liters_used
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: total_run_time_regen
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_brine_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_backwash_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_backwash2_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_rinse_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_fill_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_service_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_total_run_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: leakage_detected
    type: bool
    restore_value: no
    initial_value: 'false'

script:
  ### On reboot or powerloss of the esp, set the time left, last regeneration time, and capacity counters
  # Script "on_boot"
  - id: on_boot
    then:
      - component.update: clack_saltfill_last # add old date to dashboard when boot
      - component.update: clack_resinclean_last # add old date to dashboard when boot
      - component.update: clack_regeneration_last # add old date to dashboard when boot
      - component.update: clack_capacity_days # add old date to dashboard when boot
      - component.update: clack_time_to_resinclean # add old time to dashboard when boot
      - component.update: clack_time_to_regen # add old time to dashboard when boot
      - component.update: clack_distance # add old distance to dashboard when boot
      - pulse_meter.set_total_pulses: # Publish the initial state of totalWaterUsage on boot
          id: clack_flow_rate
          value: !lambda |-
            return id(totalWaterUsage) * id(pulse_per_liter);
      - sensor.template.publish: # Set initial value of water flow rate to 0 to avoid Unknown value
          id: clack_flow_rate
          state: 0
      - text_sensor.template.publish:
          id: clack_cycle_step
          state: !lambda |-
            return id(cycle_step) = "Idle";
      - component.update: clack_save_total_liters_used
      - component.update: clack_save_total_operation_time
      - component.update: clack_backwash_time
      - component.update: clack_brine_time
      - component.update: clack_backwash2_time
      - component.update: clack_rinse_time
      - component.update: clack_fill_time
      - component.update: clack_service_time
      - component.update: clack_cycle_runtime
      - component.update: clack_cycle_total_runtime
      - component.update: clack_total_run_time
      - component.update: clack_watermeter_total
      #- lambda: 'id(wait_on_delay) = false;'
      #- lambda: 'id(water_meter_freeze) = false;'

  ### Define a script that waits for a specified amount of time and then sets the leakage alarm bool
  # Script "check_leakage"
  - id: check_leakage
    mode: restart
    then:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            # Use a lambda expression to return the delay in milliseconds
            - delay: !lambda "return id(duration_leakage) * 60 * 1000;"
            - lambda: 'id(leakage_detected) = true;'
            - wait_until:
                condition:
                  binary_sensor.is_off: clack_water_flowing
                timeout: 20s
            - lambda: 'id(leakage_detected) = false;'

  ### Define a script that sets a motor run to simulate steps.
  # Script "clack_motor_run"
  - id: clack_motor_run
    then:
      - lambda: 'id(motor_run) = true;'
      - delay: 100ms
      - lambda: 'id(motor_run) = false;'

###  Define a script that turns on the chlorinator relay, waits for the duration, and turns it off
  - id: chlorinator_start
    mode: restart
    then:
      - switch.turn_on: chlorinator_relay
      # Use a lambda expression to return the delay in milliseconds
      - delay: !lambda "return id(duration) * 60 * 1000;"
      - switch.turn_off: chlorinator_relay

  - id: chlorinator_stop
    mode: restart
    then:
      - switch.turn_off: chlorinator_relay

  ### Define a script that resets the watermeter during regeneration
  # Script "reset_water_meter"
  - id: reset_water_meter
    mode: restart
    then:
      - lambda: |-
          id(totalWaterUsage) = 0.0;
      - component.update: clack_watermeter_total
      - pulse_meter.set_total_pulses:
          id: clack_flow_rate
          value: !lambda |-
            return id(totalWaterUsage) * id(pulse_per_liter);

  ### Define a script that visualize the cycle steps in regeneration
  # Script "decide_cycle"
  - id: decide_cycle
    mode: restart
    then:
      - script.execute: clack_motor_run  #give pulse when motor runs to different step.
      # Upflow - Post fill    : BRINE/BACKWASH/RINSE/FILL
      # Upflow - Pre fill     : FILL/SERVICE/BRINE/BACKWASH/RINSE
      # Downflow - Post fill  : BACKWASH/BRINE/BACKWASH2/RINSE/FILL
      # Downflow - Pre fill   : FILL/SERVICE/BACKWASH/BRINE/BACKWASH2/RINSE
      - if:
          condition:
            lambda: 'return id(wait_on_delay) == false;'
          then:
            - lambda: |-
                std::string clack_cycle = id(clack_select_cycle).state;
                
                if (clack_cycle == "${clack_upflow_post_fill}") {
                  id(cycle_steps_post_upflow).execute();
                } else if (clack_cycle == "${clack_upflow_pre_fill}") {
                  id(cycle_steps_pre_upflow).execute();
                } else if (clack_cycle == "${clack_downflow_post_fill}") {
                  id(cycle_steps_post_downflow).execute();
                } else if (clack_cycle == "${clack_downflow_pre_fill}") {
                  id(cycle_steps_pre_downflow).execute();
                }

###  Define a script that visualize the cycle steps in regeneration cycle "post" and "Upflow brining"
  - id: cycle_steps_post_upflow
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ################
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_operation_time
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;
      - lambda: |-
          id(regen_last) = id(sntp_time).now().timestamp;
      - component.update: clack_regeneration_last
      # Step 1: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 4800s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 2: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 3: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      # Step 4: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 400s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 35s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration cycle "pre" and "Upflow brining"
  - id: cycle_steps_pre_upflow
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 400s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_operation_time
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - lambda: |-
          id(regen_last) = id(sntp_time).now().timestamp;
      - component.update: clack_regeneration_last
      - script.execute: reset_water_meter  #Set watermeter to 0 ltr
      - lambda: 'id(water_meter_freeze) = true;'
      # Step 3: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 4800s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 4: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
         condition:
           - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
         then:
           - script.execute: chlorinator_stop
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 5: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 35s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration cycle "post" and "Downflow brining"
  - id: cycle_steps_post_downflow
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ################
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_operation_time
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - lambda: |-
          id(regen_last) = id(sntp_time).now().timestamp;
      - component.update: clack_regeneration_last
      # Step 1: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      # Step 2: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 4800s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 3: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 4: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      # Step 5: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 10s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 400s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 35s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration cycle "pre" and "Downflow brining"
  - id: cycle_steps_pre_downflow
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 400s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_operation_time
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - lambda: |-
          id(regen_last) = id(sntp_time).now().timestamp;
      - component.update: clack_regeneration_last
      - script.execute: reset_water_meter  #Set watermeter to 0 ltr
      - lambda: 'id(water_meter_freeze) = true;'
      # Step 3: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 4: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 4800s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 5: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
         condition:
           - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
         then:
           - script.execute: chlorinator_stop
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash2 time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 6: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 12s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 35s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              return id(start_time) > 0;
          then:
            - component.update: clack_cycle_runtime
      - if:
          condition:
            lambda: |-
              return id(start_time_total) > 0;
          then:
            - component.update: clack_cycle_total_runtime

binary_sensor:
  - platform: template
    name: ${clack_motor_running}
    id: bin_sens_motor_run
    internal: false
    lambda: |-
      if (id(motor_run)) {
        return true;
      } else {
        return false;
      }

  - platform: template
    name: ${clack_water_flowing}
    id: clack_water_flowing
    lambda: |-
      return (id(clack_flow_rate).state > 0);
    on_state:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            - script.execute: check_leakage

  - platform: template
    name: ${clack_water_leakage}
    icon: mdi:home-flood
    id: clack_water_leakage
    lambda: |-
      return id(leakage_detected);

button:
  ### ESP restart button
  # Button "restart_button"
  - platform: restart
    id: restart_button
    name: ${clack_restart}
    icon: mdi:button-pointer

  ### ESP restart (safe mode) button
  # Button "safe_mode_button"
  - platform: safe_mode
    id: safe_mode_button
    name: ${clack_safe_mode}
    icon: mdi:button-pointer

  # Button "test_motor_run"
  - platform: template
    name: ${clack_test_motor_run}
    id: test_motor_run
    on_press:
      then:
        - script.execute: clack_motor_run  #give pulse when motor runs to different step.
        - if:
            condition:
              lambda: 'return id(wait_on_delay) == false;'
            then:
              - script.execute: decide_cycle #choose what regeneration cycle to run

#-----------
#SENSORS
#-----------
sensor:
  ##
  # Power meter - ch1- clack pcb / ch2- Atom s3 lite esp / ch3- chlorinator
  - platform: ina3221
    address: 0x41  #A0-VCC
    channel_1:
      shunt_resistance: 0.1 ohm
      power:
        id: ch1_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - or:
            - delta: 0.5
            - median:
                window_size: 7
                send_every: 4
                send_first_at: 3
          - round: 1
        on_value:
          - component.update: clack_power  #template sensor
        on_value_range:
          - above: 1.0
            then:
              - script.execute: decide_cycle  #choose what regeneration cycle to run
      bus_voltage:
        id: ch1_voltage #Voltage ch1 - 2 - 3 are the same
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          then:
            - component.update: clack_voltage  #template sensor

    channel_2:
      shunt_resistance: 0.1 ohm
      power:
        id: ch2_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          - component.update: clack_power_esp  #template sensor

    channel_3:
      shunt_resistance: 0.1 ohm
      power:
        id: ch3_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.2
          - round: 1
        on_value:
          - component.update: clack_power_chlorinator  #template sensor          
    update_interval: 1s

  ##
  # Time Of Flight distance sensor.
  # Sensor "clack_distance"
  - platform: template
    name: ${clack_distance}
    id: clack_distance
    unit_of_measurement: cm
    accuracy_decimals: 1
    icon: "mdi:arrow-expand-vertical"
    device_class: distance
    state_class: measurement
    update_interval: never
    lambda:
      return id(last_distance);
    on_value:
      then:
        - component.update: clack_height

  # Sensor "clack_watermeter_total"
  - platform: template
    id: clack_watermeter_total
    name: ${clack_watermeter_total}
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: never
    lambda: |-
      return id(totalWaterUsage);
    on_value:
      then:
        - component.update: clack_l_left

  # Sensor "clack_voltage"
  - platform: template
    id: clack_voltage
    name: ${clack_voltage}
    icon: mdi:lightning-bolt
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_voltage).state;

  # Sensor "clack_power"
  - platform: template
    id: clack_power
    name: ${clack_power}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_power).state;

  # Sensor "clack_power_esp"
  - platform: template
    id: clack_power_esp
    name: ${clack_power_esp}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch2_power).state;

  # Sensor "clack_power_chlorinator"
  - platform: template
    id: clack_power_chlorinator
    name: ${clack_power_chlorinator}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch3_power).state;

  ##
  # TOF distance sensor calculate tank_percentage
  # Sensor "clack_procent"
  #
  # Explanation of the calculation
  # max_distance = 30,0
  # min_distance = 0,0
  # salt_level_distance = 30,0
  # salt_level_height = 6,7
  # percentage = (6,7 / 30,0) * 100 = 22,333
  #
  - platform: template
    id: clack_procent
    name: ${clack_procent}
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:percent-box-outline"
    update_interval: never
    state_class: measurement
    lambda: |-
      const float max_distance = id(clack_saltlevel_height_max).state; // height in cm to lowest level
      const float min_distance = id(clack_saltlevel_height_min).state; // height in cm to highest level
      float salt_level_distance = max_distance - min_distance;
      float salt_level_height = id(clack_height).state;
      float percentage = (salt_level_height / salt_level_distance) * 100;
      return int(percentage);
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;

  ##
  # Saltlevel animation picture on dashboard
  # Sensor "clack_salt_level"
  - platform: copy
    source_id: clack_procent
    id: clack_salt_level
    name: ${clack_animation}
    filters:
    - lambda: |-
        if (x >= 80) return 100;
        else if (x >= 65 && x <= 79) return 80;
        else if (x >= 40 && x <= 64) return 60;
        else if (x >= 20 && x <= 39) return 40;
        else if (x >= 10 && x <= 19) return 20;
        else if (x >= 5 && x <= 9) return 10;
        else if (x <= 4) return 0;
        else return x;

  ##
  # TOF distance sensor calculate salt level from bottom
  # Sensor "clack_height"
  - platform: template
    id: clack_height
    name: ${clack_height}
    unit_of_measurement: cm
    accuracy_decimals: 1
    icon: "mdi:hydraulic-oil-level"
    update_interval: ${clack_height_update_interval}
    device_class: distance
    state_class: measurement
    lambda: |-
      return id(clack_saltlevel_height_max).state - id(clack_distance).state;
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;
    on_value:
      - component.update: clack_procent
      - component.update: clack_fill_salt

  #------
  # CLACK
  #------
  # Watermeter
  # Sensor "clack_m3_left"
  - platform: template
    id: clack_m3_left
    name: ${clack_m3_left}
    unit_of_measurement: mÂ³
    device_class: water
    state_class: total
    accuracy_decimals: 2
    update_interval: never
    lambda: |-
      return id(clack_l_left).state * 0.001;
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;

  # Sensor "clack_l_left"
  - platform: template
    id: clack_l_left
    name: ${clack_l_left}
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: ${watermeter_update_interval}
    lambda: |-
      return id(clack_capacity_liters).state - id(totalWaterUsage);
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;
    on_value:
      then:
        - component.update: clack_m3_left
        - component.update: clack_percent_l_left

  # Sensor "clack_percent_l_left"
  - platform: template
    id: clack_percent_l_left
    name: ${clack_percent_l_left}
    icon: mdi:water-percent
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 1
    update_interval: never
    lambda: |-
      if (id(clack_capacity_liters).state <= 0) {
        return 0;
      }
      return float((id(clack_l_left).state / id(clack_capacity_liters).state) * 100);
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;

  ##
  # Sensor "clack_percent_time_left"
  #
  # Explanation of the calculation
  # regen_last_time = 1754006400
  # current_time = 1754416905
  # total_hours = ( 1754416905 - 1754006400) / 3600 = 114,029
  # capacity_hours = 14 * 24 = 336
  # remaining_hours = 336 - 114,029 = 221,971;
  # percentage = (221,971 / 336) * 100 = 66,063
  #
  - platform: template
    id: clack_percent_time_left
    name: ${clack_percent_time_left}
    icon: mdi:progress-clock
    unit_of_measurement: "%"
    device_class: duration
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 600s
    lambda: |-
      float regen_last_time = id(regen_last);

      if (regen_last_time <= 0) {
        return 0;
      }
      
      float current_time = id(sntp_time).now().timestamp;
      float total_hours = (current_time - regen_last_time) / 3600;
      float capacity_hours = int(id(clack_capacity_days).state) * 24;
      float remaining_hours = capacity_hours - total_hours;
      float percentage = (remaining_hours / capacity_hours) * 100;
      return percentage;
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;

  ##
  # Sensor "clack_save_total_operation_time"
  - platform: template
    name: clack_save_total_operation_time
    id: clack_save_total_operation_time
    icon: mdi:water-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_total_operation_time);
    on_value:
      then:
        - component.update: clack_save_total_operation_time_txt

  ##
  # Sensor "clack_save_total_liters_used"
  - platform: template
    name: ${clack_save_total_liters_used}
    id: clack_save_total_liters_used
    icon: mdi:water-check-outline
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: never
    lambda: |-
      return id(save_total_liters_used);

  ##
  # Sensor "clack_cycle_runtime"
  - platform: template
    name: clack_cycle_runtime
    id: clack_cycle_runtime
    icon: mdi:clock-start
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      if (id(start_time) > 0) {
        return id(sntp_time).now().timestamp - id(start_time);
      }
      return 0;
    on_value:
      then:
        - component.update: timer1

  ##
  # Sensor "clack_cycle_total_runtime"
  - platform: template
    name: clack_cycle_total_runtime
    id: clack_cycle_total_runtime
    icon: mdi:clock-start
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      if (id(start_time_total) > 0) {
        return id(sntp_time).now().timestamp - id(start_time_total);
      }
      return 0;
    on_value:
      then:
        - component.update: timer2

  ##
  # Sensor "clack_brine_time"
  - platform: template
    name: clack_brine_time
    id: clack_brine_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_brine_time);
    on_value:
      then:
        - component.update: clack_brine_time_txt

  ##
  # Sensor "clack_backwash_time"
  - platform: template
    name: clack_backwash_time
    id: clack_backwash_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash_time);
    on_value:
      then:
        - component.update: clack_backwash_time_txt

  ##
  # Sensor "clack_backwash2_time"
  - platform: template
    name: clack_backwash2_time
    id: clack_backwash2_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash2_time);
    on_value:
      then:
        - component.update: clack_backwash2_time_txt

  ##
  # Sensor "clack_rinse_time"
  - platform: template
    name: clack_rinse_time
    id: clack_rinse_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_rinse_time);
    on_value:
      then:
        - component.update: clack_rinse_time_txt

  ##
  # Sensor "clack_fill_time"
  - platform: template
    name: clack_fill_time
    id: clack_fill_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_fill_time);
    on_value:
      then:
        - component.update: clack_fill_time_txt

  ##
  # Sensor "clack_service_time"
  - platform: template
    name: clack_service_time
    id: clack_service_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_service_time);
    on_value:
      then:
        - component.update: clack_service_time_txt

  ##
  # Sensor "clack_total_run_time"
  - platform: template
    name: clack_total_run_time
    id: clack_total_run_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_total_run_time);
    on_value:
      then:
        - component.update: clack_total_run_time_txt

  # Sensor "internal_temperature"
  - platform: internal_temperature
    name: "Internal Temperature"
    device_class: temperature
    state_class: measurement

select:
  # Select "clack_select_chl_or_dpsw"
  - id: clack_select_chl_or_dpsw
    name: ${clack_select_chl_or_dpsw}
    platform: template
    options:
      - ${clack_off}
      - ${clack_chlorinator}
    initial_option: ${clack_off}
    optimistic: true
    restore_value: true
    entity_category: config
    update_interval: never

  # Select "clack_select_cycle"
  - id: clack_select_cycle
    name: ${clack_regeneration_mode}
    platform: template
    optimistic: true
    restore_value: true
    options:
      - ${clack_upflow_post_fill}
      - ${clack_upflow_pre_fill}
      - ${clack_downflow_post_fill}
      - ${clack_downflow_pre_fill}
    initial_option: ${clack_downflow_post_fill}
    entity_category: config
    update_interval: never

##
# Text sensors with general information.
text_sensor:
  ##
  # Expose ESPHome version as sensor.
  # Textsensor "clack_version"
  - platform: version
    id: clack_version
    name: ${clack_version}
    hide_timestamp: true

  ##
  # Expose WiFi information as sensors.
  # Textsensor "wifi_info"
  - platform: wifi_info
    ip_address:
      name: ${clack_ip}
      icon: mdi:ip-network

  ##
  # Textsensor "clack_fill_salt" yes or no.
  - platform: template
    name: ${clack_fill_salt}
    id: clack_fill_salt
    icon: mdi:basket-fill
    update_interval: never
    lambda: |-
      if (id(clack_height).state < id(clack_saltlevel_height_fill).state) {
        return std::string("${clack_yes}");
      } else {
        return std::string("${clack_no}");
      }

  ##
  # Textsensor "clack_cycle_step"
  - platform: template
    name: ${clack_cycle_step}
    id: clack_cycle_step
    icon: mdi:basket-fill
    update_interval: never
    lambda: |-
      return id(cycle_step);

  ##
  # Textsensor "clack_time_to_regen"
  #
  # Explanation of the calculation
  # regen_last_time = 1754006400
  # current_time = 1754416905
  # total_hours = ( 1754416905 - 1754006400) / 3600 = 114,029
  # capacity_hours = 14 * 24 = 336
  # remaining_hours = 336 - 114,029 = 221,971;
  # days = 221,971 / 24 = 9,249 = 9
  # hours = 221,971 % 24 = 5,971 = 6
  #
  - platform: template
    name: ${clack_time_to_regen}
    id: clack_time_to_regen
    icon: mdi:clock-outline
    update_interval: 600s
    lambda: |-
      char str[32];
      int64_t regen_last_time = id(regen_last);

      if (regen_last_time <= 0) {
        return std::string("Unknown");
      }

      int64_t current_time = id(sntp_time).now().timestamp;
      int64_t total_hours = (current_time - regen_last_time) / 3600;
      int64_t capacity_hours = int(id(clack_capacity_days).state) * 24;
      int64_t remaining_hours = capacity_hours - total_hours;
      int days = remaining_hours / 24;
      int hours = remaining_hours % 24;
      ${format_datetime_dh}

  ##
  # Textsensor "clack_time_to_resinclean"
  #
  # Explanation of the calculation
  # resinclean_last_time = 1754006400
  # current_time = 1754416905
  # total_hours = ( 1754416905 - 1754006400) / 3600 = 114,029
  # capacity_hours = 120 * 24 = 2880
  # remaining_hours = 2880 - 114,029 = 2765,971;
  # days = 2765,971 / 24 = 115,249 = 9
  # hours = 2765,971 % 24 = 5,971 = 6
  #
  - platform: template
    name: ${clack_time_to_resinclean}
    id: clack_time_to_resinclean
    icon: mdi:bacteria-outline
    update_interval: 600s
    lambda: |-
      char str[32];
      int64_t resinclean_last_time = id(resinclean_last);

      if (resinclean_last_time <= 0) {
        return std::string("Unknown");
      }
      
      int64_t current_time = id(sntp_time).now().timestamp;
      int64_t total_hours = (current_time - resinclean_last_time) / 3600;
      int64_t capacity_hours = int(id(resinclean_capacity_days).state) * 24;
      int64_t remaining_hours = capacity_hours - total_hours;
      int days = remaining_hours / 24;
      int hours = remaining_hours % 24;
      ${format_datetime_dh}

  ##
  # Textsensor "timer1"
  - platform: template
    name: ${clack_cycle_runtime}
    id: timer1
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      int time = int(id(clack_cycle_runtime).state);
      ${format_datetime_hms}

  ##
  # Textsensor "timer2"
  - platform: template
    name: ${clack_cycle_total_runtime}
    id: timer2
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      int time = int(id(clack_cycle_total_runtime).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_save_total_operation_time_txt"
  - platform: template
    name: ${clack_save_total_operation_time}
    id: clack_save_total_operation_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int64_t operation_time = int(id(clack_save_total_operation_time).state);
      
      if (operation_time <= 0) {
        ESP_LOGI("main", "Fallback to 'save_total_time_used' since the new 'save_total_operation_time' does not have the operation time set yet: %f", id(save_total_time_used));
        return std::string(id(save_total_time_used));
      }
      
      int64_t total_hours = operation_time / 3600;      
      int days = total_hours / 24;
      int hours = total_hours % 24;
      
      ${format_datetime_dh}

  #
  ### saved times previous cycle to formatted text.
  ##
  # Textsensor "clack_brine_time_txt"
  - platform: template
    name: ${clack_brine_time_txt}
    id: clack_brine_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_brine_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_backwash_time_txt"
  - platform: template
    name: ${clack_backwash_time_txt}
    id: clack_backwash_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_backwash_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_backwash2_time_txt"
  - platform: template
    name: ${clack_backwash2_time_txt}
    id: clack_backwash2_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_backwash2_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_rinse_time_txt"
  - platform: template
    name: ${clack_rinse_time_txt}
    id: clack_rinse_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_rinse_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_fill_time_txt"
  - platform: template
    name: ${clack_fill_time_txt}
    id: clack_fill_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_fill_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_service_time_txt"
  - platform: template
    name: ${clack_service_time_txt}
    id: clack_service_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_service_time).state);
      ${format_datetime_hms}

  ##
  # Textsensor "clack_total_run_time_txt"
  - platform: template
    name: ${clack_total_run_time_txt}
    id: clack_total_run_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      int time = int(id(clack_total_run_time).state);
      ${format_datetime_hms}

##
# imput numbers as sliders for setting the dimensions of the tank and level alarm.
number:
  ##
  # Set pulse per liters flowmeter
  # Number "clack_set_pulse_per_liters"
  - platform: template
    id: clack_set_pulse_per_liters
    name: ${clack_set_pulse_per_liters}
    icon: mdi:pulse
    optimistic: true
    mode: box
    step: 0.05
    entity_category: config
    min_value: 0
    max_value: 50
    initial_value: 28.60
    restore_value: yes
    unit_of_measurement: ""
    on_value:
      then:
        - lambda: |-
            id(pulse_per_liter) = float(x);

  ##
  # Set minimum distance (from bottom sensor / above plastic cap)
  # Number "clack_saltlevel_height_min"
  - platform: template
    id: clack_saltlevel_height_min
    name: ${clack_saltlevel_height_min}
    icon: mdi:toggle-switch-variant
    optimistic: true
    mode: slider
    step: 0.5
    entity_category: config
    min_value: 0
    max_value: 10
    initial_value: 0
    restore_value: yes
    unit_of_measurement: cm
    on_value:
      then:
        - component.update: clack_height

  ##
  # Set maximum distance (from bottom sensor / underneath plastic cap) to water level (to measure in pipe?)
  # Number "clack_saltlevel_height_max"
  - platform: template
    id: clack_saltlevel_height_max
    name: ${clack_saltlevel_height_max}
    icon: mdi:toggle-switch-variant-off
    optimistic: true
    mode: slider
    step: 0.5
    entity_category: config
    min_value: 0
    max_value: 100
    initial_value: 30
    restore_value: yes
    unit_of_measurement: cm
    on_value:
      then:
        - component.update: clack_height

  ##
  # Set alarm level
  # Number "clack_saltlevel_height_fill"
  - platform: template
    id: clack_saltlevel_height_fill
    name: ${clack_saltlevel_height_fill}
    icon: mdi:hydraulic-oil-temperature
    optimistic: true
    mode: slider
    step: 0.1
    entity_category: config
    min_value: 0
    max_value: 10
    initial_value: 1.5
    restore_value: yes
    unit_of_measurement: cm
    update_interval: never
    on_value:
      then:
        - component.update: clack_height

  ##
  # Set capacity liters
  # Number "clack_capacity_liters"
  - platform: template
    id: clack_capacity_liters
    name: ${clack_capacity_liters}
    icon: mdi:water-opacity
    optimistic: true
    mode: box
    step: 50
    entity_category: config
    min_value: 0
    max_value: 12000
    initial_value: 3700
    restore_value: yes
    unit_of_measurement: L
    on_value:
      then:
        - component.update: clack_l_left

  ##
  # Set capacity days
  # Number "clack_capacity_days"
  - platform: template
    id: clack_capacity_days
    name: ${clack_capacity_days}
    icon: mdi:calendar-clock
    optimistic: true
    mode: box
    step: 1
    entity_category: config
    min_value: 0
    max_value: 21
    initial_value: 14
    restore_value: yes
    unit_of_measurement: ${days}
    on_value:
      then:
        - component.update: clack_time_to_regen
        - component.update: clack_percent_time_left
  ##
  # Set resinclean capacity days
  # Number "resinclean_capacity_days"
  - platform: template
    id: resinclean_capacity_days
    name: ${clack_resinclean_capacity_days}
    icon: mdi:calendar-clock
    optimistic: true
    mode: box
    step: 1
    entity_category: config
    min_value: 0
    max_value: 365
    initial_value: 120
    restore_value: yes
    unit_of_measurement: ${days}
    on_value:
      then:
        - component.update: clack_time_to_resinclean
  ##
  # Set chlorinator relay off-delay
  # Number "clack_chlorinator_delay"
  - platform: template
    id: clack_chlorinator_delay
    name: ${clack_chlorinator_delay}
    icon: mdi:toggle-switch-variant
    optimistic: true
    mode: box
    step: 1
    entity_category: config
    min_value: 0
    max_value: 45
    initial_value: 10
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - lambda: |-
            id(duration) = int(x);

  ##
  # Set minimum time delay for leakage alarm
  # Number "clack_leakage_alarm_delay"
  - platform: template
    id: clack_leakage_alarm_delay
    name: ${clack_leakage_alarm_delay}
    icon: mdi:home-flood
    optimistic: true
    mode: box
    step: 1
    entity_category: config
    min_value: 0
    max_value: 60
    initial_value: 30
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - lambda: |-
            id(duration_leakage) = int(x);


  ##
  # Set minimum time delay for considering water flow stopped
  - platform: template
    id: clack_water_flow_timeout_delay
    name: ${clack_water_flow_timeout_delay}
    icon: mdi:waves-arrow-right
    optimistic: true
    mode: box
    step: 0.1
    entity_category: config
    min_value: 0
    max_value: 300
    initial_value: 6.5
    restore_value: yes
    unit_of_measurement: "s"
    on_value:
      then:
        - lambda: |-
            id(duration_water_flow_timeout) = float(x);
        - lambda: |-
            uint32_t timeout = id(duration_water_flow_timeout) * 1000000UL;
            id(clack_flow_rate).set_timeout_us(timeout);

substitutions:
  format_datetime_readable: |-
    char str[32];
    strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&datetime));
    return std::string(str);

  format_datetime_hms: |-
    char str[32];
    int sec = time;
    int min = sec / 60;
    int hrs = sec / 3600;
    sec %= 60;
    min %= 60;
    
    if (hrs > 0) {
      snprintf(str, sizeof(str), "%ih %im %is", hrs, min, sec);
    } else if (min > 0) {
      snprintf(str, sizeof(str), "%im %is", min, sec);
    } else {
      snprintf(str, sizeof(str), "%is", sec);
    }
    return std::string(str);

  format_datetime_dh: |-
    if (days > 0) {
      snprintf(str, sizeof(str), "%id %ih", days, hours);
    } else {
      snprintf(str, sizeof(str), "%ih", hours);
    }
    return std::string(str);
