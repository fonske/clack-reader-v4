# Basics
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  includes:
    - water_flow.h
  on_boot:
    priority: -100
    then:
      - script.execute: on_boot

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  services:
    - service: water_meter_value  # set the water meter to any value in liters
      variables:
        meter_value: float
      then:
        - globals.set:
            id: totalWaterUsage
            value: !lambda "return ( meter_value ) ;"
        - sensor.template.publish:
            id: clack_watermeter
            state: !lambda |-
              return id(totalWaterUsage);

globals:
  - id: totalWaterUsage
    type: float
    restore_value: yes
#    initial_value: '00'

# Clack DV flowmeter 27.60  / Clack WS1: 16.80 / (to be checked)
  - id: pulse_per_liter
    type: float
    restore_value: yes
    initial_value: '16.80'

# Define a global variable for the chlorinator delay duration in minutes
  - id: duration
    type: int
    restore_value: yes
    initial_value: '15'

# Define a global variable for the chlorinator delay duration in minutes
  - id: duration_leakage
    type: int
    restore_value: yes
    initial_value: '30'

# Define a global variable for last regeneration time
  - id: cycle_step
    type: std::string
    restore_value: yes
    initial_value: '"Idle"'
 
  # Define a global variable for last regeneration datetime
  - id: regen_date_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

# Define a global variable for last regeneration time
  - id: regen_last
    type: int
    restore_value: yes
#    initial_value: "0"

 # Define a global variable for resinclean datetime
  - id: resinclean_date_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

 # Define a global variable for resinclean time
  - id: resinclean_last
    type: int
    restore_value: yes
#    initial_value: "0"

 # Define a global variable for fill_last datetime
  - id: fill_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

# Define a global variable that blocks a new reg cycle
  - id: wait_on_delay
    type: bool
    restore_value: yes

# Define a global variable that blocks a new reg cycle
  - id: water_meter_freeze
    type: bool
    restore_value: yes

# Define a global variable that shows motor run
  - id: motor_run
    type: bool
    restore_value: yes

# cycle timer
  - id: start_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time
    type: int
    restore_value: yes
    initial_value: '0'

# cycle timer total
  - id: start_time_total
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time_total
    type: int
    restore_value: yes
    initial_value: '0'

### record last settings during regen.
  - id: save_total_time_used
    type: std::string
    restore_value: yes
    initial_value: '"Unknown"'

  - id: save_total_liters_used
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: total_run_time_regen
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_brine_time
    type: int
    restore_value: yes
    initial_value: '0'
  
  - id: save_backwash_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_backwash2_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_rinse_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_fill_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_service_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_total_run_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: leakage_detected
    type: bool
    restore_value: no
    initial_value: 'false'

script:
###  On reboot or powerloss of the esp, set the time left, last regeneration time, and capacity counters
  - id: on_boot
    then:
      - component.update: clack_saltfill_last  # add old date to dashboard when boot
      - component.update: clack_resinclean_last # add old date to dashboard when boot
      - component.update: clack_regeneration_last # add old date to dashboard when boot
      - component.update: time_to
      - component.update: clack_percent_time_left
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - component.update: clack_save_total_liters_used
      - component.update: clack_save_total_time_used
      - component.update: clack_backwash_time
      - component.update: clack_brine_time
      - component.update: clack_backwash2_time
      - component.update: clack_rinse_time
      - component.update: clack_fill_time
      - component.update: clack_service_time
      - component.update: clack_total_run_time

### Define a script that waits for a specified amount of time and then sets the leakage alarm bool
  - id: check_leakage
    mode: restart
    then:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            # Use a lambda expression to return the delay in milliseconds
            - delay: !lambda "return id(duration_leakage) * 60 * 1000;"
            - lambda: 'id(leakage_detected) = true;'
            - wait_until:
                condition:
                  binary_sensor.is_off: clack_water_flowing
                timeout: 20s
            - lambda: 'id(leakage_detected) = false;'

###  Define a script that sets a motor run to simulate steps.
  - id: clack_motor_run
    then:
      - lambda: 'id(motor_run) = true;'
      - delay: 100ms 
      - lambda: 'id(motor_run) = false;'

###  Define a script that turns on the chlorinator relay, waits for the duration, and turns it off
  - id: chlorinator_start
    mode: restart
    then:
      - switch.turn_on: chlorinator_relay
      # Use a lambda expression to return the delay in milliseconds
      - delay: !lambda "return id(duration) * 60 * 1000;"
      - switch.turn_off: chlorinator_relay

  - id: chlorinator_stop
    mode: restart
    then:
      - switch.turn_off: chlorinator_relay

###  Define a script that resets the watermeter during regeneration
  - id: reset_water_meter
    mode: restart
    then:
      - globals.set:
          id: totalWaterUsage
          value: '00'        
      - sensor.template.publish:
          id: clack_watermeter
          state: !lambda |-
            return id(totalWaterUsage);

###  Define a script that visualize the cycle steps in regeneration cycle 4 steps
  - id: cycle_steps_4cycle_post
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ################
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 1: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ###############################################
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      ######################################################
      # Step 2: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 3: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      # Step 4: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 25s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration cycle 5 steps
  - id: cycle_steps_5cycle_post
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 1: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 2: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 3: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
       ## store Backwash2 time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 4: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      # Step 5: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 25s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      ##reset all timers
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 4 step cycle "pre"
  - id: cycle_steps_4cycle_pre
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 4: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 5: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre"
  - id: cycle_steps_5cycle_pre
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 4: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 5: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
       ## store Backwash2 time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 6: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre"
  - id: decide_cycle
    mode: restart
    then:
      - script.execute: clack_motor_run  #give pulse when motor runs to different step.
      #4 Pre fill no 2nd Backwash  : FILL/SERVICE/BACKWASH/BRINE/RINSE
      #5 Pre fill 2nd Backwash     : FILL/SERVICE/BACKWASH/BRINE/BACKWASH2/RINSE
      #4 Post fill no 2nd Backwash : BACKWASH/BRINE/RINSE/FILL
      #5 sPost fill 2nd Backwash   : BACKWASH/BRINE/BACKWASH2/RINSE/FILL                  
      - if:
          condition:
            lambda: 'return id(wait_on_delay) == false;'
          then:
            - if:
                condition:
                  lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_no_2nd_backwash}";'
                then:
                  - script.execute: cycle_steps_4cycle_pre   # fill/service/backwash/brine/backwash2/rinse
                else:
                  - if:
                      condition:
                        lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_2nd_backwash}";'
                      then:
                        - script.execute: cycle_steps_5cycle_pre  # fill/service/backwash/brine/backwash2/rinse  
                      else:
                        - if:
                            condition:
                              lambda: 'return id(clack_select_cycle).state == "${clack_post_fill_no_2nd_backwash}";'
                            then:
                              - script.execute: cycle_steps_4cycle_post # backwash/brine/rinse/fill    
                            else:
                              - if:
                                  condition:
                                    lambda: 'return id(clack_select_cycle).state == "${clack_post_fill_2nd_backwash}";'
                                  then:
                                    - script.execute: cycle_steps_5cycle_post  # backwash/brine/backwash2/rinse/fill

interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              return id(start_time) != 0;
          then:
            - lambda: |- 
                id(run_time) = id(sntp_time).now().timestamp - id(start_time);
            - component.update: timer1
          else:
            - lambda: |-
                id(run_time) = 0;
      - if:
          condition:
            lambda: |-
              return id(start_time_total) != 0;
          then:
            - lambda: |- 
                id(run_time_total) = id(sntp_time).now().timestamp - id(start_time_total);
            - component.update: timer2
          else:
            - lambda: |-
                id(run_time_total) = 0;

binary_sensor:
  - platform: template
    name: ${clack_motor_running}
    id: bin_sens_motor_run
    internal: false
    lambda: |-
      if (id(motor_run)) {
        return true;
      } else {
        return false;
      }

  - platform: template
    name: ${clack_water_flowing}
    id: clack_water_flowing
    lambda: |-
      return (id(clack_flow_rate).state > 0);
    on_state:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            - script.execute: check_leakage

  - platform: template
    name: ${clack_water_leakage}
    icon: mdi:home-flood
    id: clack_water_leakage
    lambda: |-
      return id(leakage_detected);

###  ESP restart button
button:
  - platform: restart
    id: restart_button
    name: ${clack_restart}

###  ESP restart (safe mode) button
  - platform: safe_mode
    id: safe_mode_button
    name: ${clack_safe_mode}

####################################test
  - platform: template
    name: ${clack_test_motor_run}
    id: test_motor_run
    on_press:
      then:
        - script.execute: clack_motor_run  #give pulse when motor runs to different step.
        - if:
            condition:
              lambda: 'return id(wait_on_delay) == false;'
            then:
              - script.execute: decide_cycle #choose what regeneration cycle to run

#-----------
#SENSORS
#-----------
sensor:
  ##
  # Power meter - ch1- clack pcb / ch2- Atom s3 lite esp / ch3- chlorinator
  - platform: ina3221
    address: 0x41  #A0-VCC
    channel_1:
      shunt_resistance: 0.1 ohm
      power:
        id: ch1_power
        name: ch1_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - or:
            - delta: 0.4
            - median:
                window_size: 7
                send_every: 4
                send_first_at: 3
          - round: 1
        on_value:
          - component.update: clack_power  #template sensor
        on_value_range:
          - above: 1.0
            then:
              - script.execute: decide_cycle  #choose what regeneration cycle to run
      bus_voltage:
        id: ch1_voltage #Voltage ch1 - 2 - 3 are the same
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          then:
            - component.update: clack_voltage  #template sensor

    channel_2:
      shunt_resistance: 0.1 ohm
      power:
        id: ch2_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          - component.update: clack_power_esp  #template sensor

    channel_3:
      shunt_resistance: 0.1 ohm
      power:
        id: ch3_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.2
          - round: 1
        on_value:
          - component.update: clack_power_chlorinator  #template sensor          
    update_interval: 1s

  - platform: template
    id: clack_voltage
    name: ${clack_voltage}
    icon: mdi:lightning-bolt
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_voltage).state;

  - platform: template
    id: clack_power
    name: ${clack_power}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_power).state;

  - platform: template
    id: clack_power_esp
    name: ${clack_power_esp}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch2_power).state;

  - platform: template
    id: clack_power_chlorinator
    name: ${clack_power_chlorinator}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch3_power).state;

#------
# CLACK
#------
  ##
  #  Flow Rate
  - platform: custom
    lambda: |-
      auto wf = new WaterFlowSensor();
      App.register_component(wf);
      return {wf->clack_flow_rate};

    sensors:
    - name: ${clack_flow_rate}
      icon: mdi:waves-arrow-right
      unit_of_measurement: L/min # Gallons GPM or Liters per minute 
      accuracy_decimals: 2
      id: clack_flow_rate
      device_class: volume_flow_rate
      state_class: measurement



  #  Watermeter
  - platform: template
    id: clack_watermeter
    name: ${clack_watermeter_total}
    icon: mdi:water
    update_interval: ${watermeter_update_interval}
    unit_of_measurement: L
    device_class: water
    state_class: total_increasing
    accuracy_decimals: 1
    on_value:
      - sensor.template.publish:
          id: clack_m3_left
          state: !lambda |-
            return float(id(clack_capacity_liters).state - id(clack_watermeter).state) * 0.001;
      - sensor.template.publish:
          id: clack_l_left
          state: !lambda |-
            return int(id(clack_capacity_liters).state - id(clack_watermeter).state);
      - sensor.template.publish:
          id: clack_percent_l_left
          state: !lambda |-
            if (id(clack_capacity_liters).state <= 0) {
            return 0;
            }
            return float((id(clack_l_left).state / id(clack_capacity_liters).state) * 100);

  - platform: template
    id: clack_m3_left
    name: ${clack_m3_left}
    unit_of_measurement: mÂ³
    device_class: water
    state_class: total
    accuracy_decimals: 2
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;

  - platform: template
    id: clack_l_left
    name: ${clack_l_left}
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 0
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;

  - platform: template
    id: clack_percent_l_left
    name: ${clack_percent_l_left}
    icon: mdi:water-percent
    unit_of_measurement: "%"
    device_class: water
    state_class: measurement
    accuracy_decimals: 1
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;

  - platform: template
    id: clack_percent_time_left
    name: ${clack_percent_time_left}
    icon: mdi:progress-clock
    unit_of_measurement: "%"
    device_class: duration
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 600s
    lambda: |-
      if(id(regen_last) == 0){
        return 0;
      }
      float resthours = (id(regen_last) - id(sntp_time).now().timestamp) / 3600 + (id(clack_capacity_days).state * 24);
      float capdays = id(clack_capacity_days).state * 24;
      float procent = (resthours / capdays) *100;
      return procent;
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;


  - platform: template
    name: ${clack_save_total_liters_used}
    id: clack_save_total_liters_used
    icon: mdi:water-check-outline
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: never
    lambda: |-
      return id(save_total_liters_used);

  - platform: template
    name: clack_brine_time
    id: clack_brine_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_brine_time);
    on_value:
      then:
        - component.update: clack_brine_time_txt

  - platform: template
    name: clack_backwash_time
    id: clack_backwash_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash_time);
    on_value:
      then:
        - component.update: clack_backwash_time_txt

  - platform: template
    name: clack_backwash2_time
    id: clack_backwash2_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash2_time);
    on_value:
      then:
        - component.update: clack_backwash2_time_txt

  - platform: template
    name: clack_rinse_time
    id: clack_rinse_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_rinse_time);
    on_value:
      then:
        - component.update: clack_rinse_time_txt

  - platform: template
    name: clack_fill_time
    id: clack_fill_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_fill_time);
    on_value:
      then:
        - component.update: clack_fill_time_txt

  - platform: template
    name: clack_service_time
    id: clack_service_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_service_time);
    on_value:
      then:
        - component.update: clack_service_time_txt

  - platform: template
    name: clack_total_run_time
    id: clack_total_run_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_total_run_time);
    on_value:
      then:
        - component.update: clack_total_run_time_txt

  - platform: internal_temperature
    name: "Internal Temperature"

select:
  - id: clack_select_chl_or_dpsw
    name: ${clack_select_chl_or_dpsw}
    platform: template
    options:
      - ${clack_off}
      - ${clack_chlorinator}
      - ${clack_dp_sw_init_regen}
      - ${clack_dp_sw_hold_regen}
    initial_option: ${clack_off}
    optimistic: true
    restore_value: true
    entity_category: config
    update_interval: never

  - id: clack_select_cycle
    name: ${clack_regeneration_mode}
    platform: template
    options:
      - ${clack_post_fill_no_2nd_backwash}
      - ${clack_post_fill_2nd_backwash}
      - ${clack_pre_fill_no_2nd_backwash}
      - ${clack_pre_fill_2nd_backwash}
    initial_option: ${clack_post_fill_no_2nd_backwash}
    optimistic: true
    restore_value: true
    entity_category: config
    update_interval: never
##
# Text sensors with general information.
text_sensor:
  ##
  # Expose ESPHome version as sensor.
  - platform: version
    id: clack_version
    name: ${clack_version}
    hide_timestamp: true

  ##
  # Expose WiFi information as sensors.
  - platform: wifi_info
    ip_address:
      name: ${clack_ip}
      icon: mdi:ip-network

  ##
  # Textsensor "Fill Salt" yes or no.
  - platform: template
    name: ${clack_fill_salt}
    id: clack_fill_salt
    icon: mdi:basket-fill
    update_interval: never

  # Textsensor "cycle_step"
  - platform: template
    name: ${clack_cycle_step}
    id: clack_cycle_step
    icon: mdi:basket-fill
    update_interval: never

  - platform: template
    name: ${clack_time_to_regen}
    id: time_to
    icon: mdi:clock-outline
    update_interval: 600s
    lambda: |-
      char str[32];
      int64_t regen_last_time = id(regen_last);
      int64_t current_time = id(sntp_time).now().timestamp;

      if (regen_last_time == 0) {
        return {"Unknown"};
      }

      int64_t total_hours = (regen_last_time - current_time) / 3600 + (id(clack_capacity_days).state * 24);
      int days = total_hours / 24;
      int hours = total_hours % 24;

      if (days > 0) {
        sprintf(str, "%id %ih", days, hours);
      } else {
        sprintf(str, "%ih", hours);
      }
      return {str};

  - platform: template
    name: ${clack_save_total_time_used}
    id: clack_save_total_time_used
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      return id(save_total_time_used);

  - platform: template
    name: ${clack_time_to_resinclean}
    id: time_to_resinclean
    icon: mdi:bacteria-outline
    update_interval: 600s
    lambda: |-
      char str[32];
      if(id(resinclean_last) == 0){
        return {"Unknown"};
      }
      int hours = (id(resinclean_last) - id(sntp_time).now().timestamp) / 3600 + (id(resinclean_capacity_days).state * 24);
      int days = hours / 24;
      hours %= 24;
      if( days > 0){
        sprintf(str, "%id %ih", days, hours);
      }
      else{
        sprintf(str, "%ih", hours);
      }
      return { str };

  - platform: template
    name: ${clack_cycle_runtime}
    id: timer1
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(run_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_cycle_total_runtime}
    id: timer2
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(run_time_total);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

#
## saved times previous cycle to formatted text.
  - platform: template
    name: ${clack_brine_time_txt}
    id: clack_brine_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_brine_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_backwash_time_txt}
    id: clack_backwash_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_backwash_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_backwash2_time_txt}
    id: clack_backwash2_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_backwash2_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_rinse_time_txt}
    id: clack_rinse_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_rinse_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_fill_time_txt}
    id: clack_fill_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_fill_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_service_time_txt}
    id: clack_service_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_service_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_total_run_time_txt}
    id: clack_total_run_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_total_run_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

##
# imput numbers as sliders for setting the dimensions of the tank and level alarm.
number:
  ##
  # Set pulse per liters flowmeter
  - platform: template
    id: clack_set_pulse_per_liters
    name: ${clack_set_pulse_per_liters}
    icon: mdi:pulse
    optimistic: true
    mode: box
    step: 0.05
    entity_category: config
    min_value: 0
    max_value: 50
    initial_value: 16.8
    restore_value: yes
    unit_of_measurement: " "
    on_value:
      then:
        - globals.set:
            id: pulse_per_liter
            value: !lambda |-
              return id(clack_set_pulse_per_liters).state;

  ##
  # Set capacity liters
  - platform: template
    id: clack_capacity_liters
    name: ${clack_capacity_liters}
    icon: mdi:water-opacity
    optimistic: true
    mode: slider
    step: 100
    entity_category: config
    min_value: 0
    max_value: 12000
    initial_value: 3700
    restore_value: yes
    unit_of_measurement: L
    on_value:
      then:
        - sensor.template.publish:
            id: clack_watermeter
            state: !lambda |-
              return id(totalWaterUsage);
  ##
  # Set capacity days
  - platform: template
    id: clack_capacity_days
    name: ${clack_capacity_days}
    icon: mdi:calendar-clock
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 21
    initial_value: 14
    restore_value: yes
    unit_of_measurement: ${days}
    on_value: 
      then:
        - component.update: time_to
        - component.update: clack_percent_time_left
  ##
  # Set resinclean capacity days
  - platform: template
    id: resinclean_capacity_days
    name: ${clack_resinclean_capacity_days}
    icon: mdi:calendar-clock
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 365
    initial_value: 120
    restore_value: yes
    unit_of_measurement: ${days}
    on_value:
      then:
        - component.update: time_to_resinclean
  ##
  # Set chlorinator relay off-delay
  - platform: template
    id: clack_chlorinator_delay
    name: ${clack_chlorinator_delay}
    icon: mdi:toggle-switch-variant
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 45
    initial_value: 10
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - globals.set:
            id: duration
            value: !lambda 'return int(x);'

  ##
  # Set minimum time delay for leakage alarm
  - platform: template
    id: clack_leakage_alarm_delay
    name: ${clack_leakage_alarm_delay}
    icon: mdi:home-flood
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 60
    initial_value: 30
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - globals.set:
            id: duration_leakage
            value: !lambda 'return int(x);'