# Basics
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -100
    then:
      - script.execute: on_boot

# Enable Home Assistant API
api:
  reboot_timeout: 0s
  actions:
    - action: water_meter_value
      variables:
        meter_value: float
      then:
        - globals.set:
            id: totalWaterUsage
            value: !lambda "return ( meter_value ) ;"
        - pulse_meter.set_total_pulses:
            id: clack_flow_rate
            value: !lambda |-
              return id(totalWaterUsage) * id(pulse_per_liter);

    - action: last_distance_value #set last measured salt distance to any value in cm.
      variables:
        new_distance_value: float
      then:
        - globals.set:
            id: last_distance
            value: !lambda "return ( new_distance_value ) ;"
        - sensor.template.publish:
            id: clack_distance
            state: !lambda |-
              return id(last_distance_cm).state;

globals:
  - id: totalWaterUsage
    type: float
    restore_value: yes
#    initial_value: '00'

# Clack DV flowmeter 27.60  / Clack WS1: 16.30 / (to be checked)
  - id: pulse_per_liter
    type: float
    restore_value: yes
    initial_value: '16.30'

# Define a global variable for the chlorinator delay duration in minutes
  - id: duration
    type: int
    restore_value: yes
    initial_value: '15'

# Define a global variable for the chlorinator delay duration in minutes
  - id: duration_leakage
    type: int
    restore_value: yes
    initial_value: '30'

# Define a global variable for the water flow timeout in seconds
  - id: duration_water_flow_timeout
    type: float
    restore_value: yes
    initial_value: '6.5'

# Define a global variable for last regeneration time
  - id: cycle_step
    type: std::string
    restore_value: yes
    initial_value: '"Idle"'
 
  # Define a global variable for last regeneration datetime
  - id: regen_date_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

# Define a global variable for last regeneration time
  - id: regen_last
    type: int
    restore_value: yes
#    initial_value: "0"

 # Define a global variable for resinclean datetime
#  - id: resinclean_date_last
#    type: std::string
#    restore_value: yes
#    initial_value: '"Never"'

 # Define a global variable for resinclean time
 # - id: resinclean_last
 #   type: int
 #   restore_value: yes
##    initial_value: "0"

 # Define a global variable for fill_last datetime
  - id: fill_last
    type: std::string
    restore_value: yes
    initial_value: '"Never"'

# Define a global variable to store last value of the distance
  - id: last_distance
    type: float
    restore_value: yes
#    initial_value: '0.00'

# Define a global variable that blocks a new reg cycle
  - id: wait_on_delay
    type: bool
    restore_value: yes

# Define a global variable that blocks a new reg cycle
  - id: water_meter_freeze
    type: bool
    restore_value: yes

# Define a global variable that shows motor run
  - id: motor_run
    type: bool
    restore_value: yes

# cycle timer
  - id: start_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time
    type: int
    restore_value: yes
    initial_value: '0'

# cycle timer total
  - id: start_time_total
    type: int
    restore_value: yes
    initial_value: '0'

  - id: run_time_total
    type: int
    restore_value: yes
    initial_value: '0'

### record last settings during regen.
  - id: save_total_time_used
    type: std::string
    restore_value: yes
    initial_value: '"Unknown"'

  - id: save_total_liters_used
    type: float
    restore_value: yes
    initial_value: '0.0'

  - id: total_run_time_regen
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_brine_time
    type: int
    restore_value: yes
    initial_value: '0'
  
  - id: save_backwash_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_backwash2_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_rinse_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_fill_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_service_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: save_total_run_time
    type: int
    restore_value: yes
    initial_value: '0'

  - id: leakage_detected
    type: bool
    restore_value: no
    initial_value: 'false'

script:
###  On reboot or powerloss of the esp, set the time left, last regeneration time, and capacity counters
  - id: on_boot
    then:
      - component.update: clack_saltfill_last  # add old date to dashboard when boot
#      - component.update: clack_resinclean_last # add old date to dashboard when boot
      - component.update: clack_regeneration_last # add old date to dashboard when boot
      - component.update: time_to
      - component.update: clack_percent_time_left
      - sensor.template.publish:
          id: clack_distance
          state: !lambda |-
            return id(last_distance_cm).state;
      - pulse_meter.set_total_pulses: # Publish the initial state of totalWaterUsage on boot
            id: clack_flow_rate
            value: !lambda |-
              return id(totalWaterUsage) * id(pulse_per_liter);
      - sensor.template.publish: # Set initial value of water flow rate to 0 to avoid Unknown value
            id: clack_flow_rate
            state: 0
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - component.update: clack_save_total_liters_used
      - component.update: clack_save_total_time_used
      - component.update: clack_backwash_time
      - component.update: clack_brine_time
      - component.update: clack_backwash2_time
      - component.update: clack_rinse_time
      - component.update: clack_fill_time
      - component.update: clack_service_time
      - component.update: clack_total_run_time
##      - lambda: 'id(wait_on_delay) = false;'
##      - lambda: 'id(water_meter_freeze) = false;'

  - id: recalculate
    then:
      - sensor.template.publish:
          id: clack_height
          state: !lambda |-
            return id(clack_saltlevel_height_max).state-id(last_distance_cm).state;
      - sensor.template.publish:
          id: clack_procent
          state: !lambda |-
            const float max_distance = id(clack_saltlevel_height_max).state; // heigt in cm to lowest level
            const float min_distance = id(clack_saltlevel_height_min).state; // height in cm to highest level
            return int((1/((max_distance - min_distance)/id(clack_height).state))*100);
      - text_sensor.template.publish:
          id: clack_fill_salt
          state: !lambda |-
            if (id(clack_height).state < id(clack_saltlevel_height_fill).state) {
              return {"${clack_yes}"};
            } else {
              return {"${clack_no}"};
            }

### Define a script that waits for a specified amount of time and then sets the leakage alarm bool
  - id: check_leakage
    mode: restart
    then:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            # Use a lambda expression to return the delay in milliseconds
            - delay: !lambda "return id(duration_leakage) * 60 * 1000;"
            - lambda: 'id(leakage_detected) = true;'
            - wait_until:
                condition:
                  binary_sensor.is_off: clack_water_flowing
                timeout: 20s
            - lambda: 'id(leakage_detected) = false;'

###  Define a script that sets a motor run to simulate steps.
  - id: clack_motor_run
    then:
      - lambda: 'id(motor_run) = true;'
      - delay: 100ms 
      - lambda: 'id(motor_run) = false;'

###  Define a script that turns on the chlorinator relay, waits for the duration, and turns it off
  - id: chlorinator_start
    mode: restart
    then:
      - switch.turn_on: chlorinator_relay
      # Use a lambda expression to return the delay in milliseconds
      - delay: !lambda "return id(duration) * 60 * 1000;"
      - switch.turn_off: chlorinator_relay

  - id: chlorinator_stop
    mode: restart
    then:
      - switch.turn_off: chlorinator_relay

###  Define a script that resets the watermeter during regeneration
  - id: reset_water_meter
    mode: restart
    then:
      - globals.set:
          id: totalWaterUsage
          value: '00'        
      - pulse_meter.set_total_pulses:
            id: clack_flow_rate
            value: !lambda |-
              return id(totalWaterUsage) * id(pulse_per_liter);

###  Define a script that visualize the cycle steps in regeneration cycle 4 steps
  - id: cycle_steps_4cycle_post
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ################
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 1: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ###############################################
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      ######################################################
      # Step 2: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 3: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      # Step 4: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 25s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration cycle 5 steps
  - id: cycle_steps_5cycle_post
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 1: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - lambda: |-
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 2: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3660s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 3: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
       ## store Backwash2 time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 4: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      # Step 5: Fill
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 25s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1500s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      ##reset all timers
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 4 step cycle "pre"
  - id: cycle_steps_4cycle_pre
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 4: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 5: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre"
  - id: cycle_steps_5cycle_pre
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Backwash
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 4: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 5: Backwash2
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash2";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_stop
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
       ## store Backwash2 time         
      - globals.set:
          id: save_backwash2_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash2_time
      # Step 6: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'
      
###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre upflow"
  - id: cycle_steps_5cycle_pre_upflow
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 4: Backwash 
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      # Step 5: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time  
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'
      
###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre upflow 2"
  - id: cycle_steps_5cycle_pre_upflow_2
    mode: single
    then:
      - lambda: 'id(wait_on_delay) = true;'
      # Step 1: Fill - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Fill";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
          id(start_time_total) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 600s
      ## store Fill time         
      - globals.set:
          id: save_fill_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_fill_time
      # Step 2: Service - keep running water meter
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Service";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 15s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 14500s
      - globals.set:
          id: save_service_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_service_time
      - lambda: 'id(wait_on_delay) = true;'
      - lambda: 'id(water_meter_freeze) = true;'
      ## store used liters
      - globals.set:
          id: save_total_liters_used
          value: !lambda |-
            return id(clack_watermeter).state;  
      - component.update: clack_save_total_liters_used
      ## store used time
      - globals.set: 
          id: save_total_time_used
          value: !lambda |-
            char str[32];
            int64_t regen_last_time = id(regen_last);
            int64_t current_time = id(sntp_time).now().timestamp;
            int64_t total_hours = (current_time - regen_last_time) / 3600;
            int days = total_hours / 24;
            int hours = total_hours % 24;
            if (days > 0) {
              snprintf(str, sizeof(str), "%id %ih", days, hours);
            } else {
              snprintf(str, sizeof(str), "%ih", hours);
            }
            return std::string(str);
      - component.update: clack_save_total_time_used
      - script.execute: reset_water_meter #Set watermeter to 0 ltr
      - globals.set:
          id: regen_last
          value: !lambda |-
            return id(sntp_time).now().timestamp;   
      - text_sensor.template.publish:
          id: clack_regeneration_last
          state: !lambda |-
            char str[32];
            time_t currTime = id(sntp_time).now().timestamp;
            strftime(str, sizeof(str), "%a %d %b %H:%M", localtime(&currTime));
            id(regen_date_last) = str;
            return  { str };
      # Step 3: Brine
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Brine";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - if:
          condition:
            - lambda: 'return id(clack_select_chl_or_dpsw).state == "Chlorinator";'
          then:
            - script.execute: chlorinator_start
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 3600s
      ## store Brine time         
      - globals.set:
          id: save_brine_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_brine_time
      # Step 4: Rinse
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Rinse";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Rinse time         
      - globals.set:
          id: save_rinse_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_rinse_time
      # Step 5: Backwash 
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Backwash";
      - lambda: |-
          id(start_time) = id(sntp_time).now().timestamp;
      - delay: 17s
      - wait_until:
          condition:
            binary_sensor.is_on: bin_sens_motor_run
          timeout: 1000s
      ## store Backwash time         
      - globals.set:
          id: save_backwash_time
          value: !lambda |-
            return id(run_time);
      - component.update: clack_backwash_time
      ## store Total run time         
      - globals.set:
          id: save_total_run_time
          value: !lambda |-
            return id(run_time_total);
      - component.update: clack_total_run_time
      # Idle
      - text_sensor.template.publish:
            id: clack_cycle_step
            state: !lambda |-
              return id(cycle_step) = "Idle";
      - lambda: |-
          id(start_time) = 0;
      - lambda: |-
          id(start_time_total) = 0;
      - component.update: timer1
      - component.update: timer2
      - delay: 30s
      - lambda: 'id(wait_on_delay) = false;'
      - lambda: 'id(water_meter_freeze) = false;'

###  Define a script that visualize the cycle steps in regeneration 5 step cycle "pre"
  - id: decide_cycle
    mode: restart
    then:
      - script.execute: clack_motor_run  #give pulse when motor runs to different step.
      #4 Pre fill no 2nd Backwash  : FILL/SERVICE/BACKWASH/BRINE/RINSE
      #5 Pre fill 2nd Backwash     : FILL/SERVICE/BACKWASH/BRINE/BACKWASH2/RINSE
      #5 Pre fill Upflow           : FILL/SERVICE/BRINE/BACKWASH/RINSE
      #5 Pre fill Upflow 2         : FILL/SERVICE/BRINE/RINSE/BACKWASH
      #4 Post fill no 2nd Backwash : BACKWASH/BRINE/RINSE/FILL
      #5 Post fill 2nd Backwash    : BACKWASH/BRINE/BACKWASH2/RINSE/FILL
      
      - if:
          condition:
            lambda: 'return id(wait_on_delay) == false;'
          then:
            - if:
                condition:
                  lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_no_2nd_backwash}";'
                then:
                  - script.execute: cycle_steps_4cycle_pre   # fill/service/backwash/brine/backwash2/rinse
                else:
                  - if:
                      condition:
                        lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_2nd_backwash}";'
                      then:
                        - script.execute: cycle_steps_5cycle_pre  # fill/service/backwash/brine/backwash2/rinse  
                      else:
                        - if:
                            condition:
                              lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_upflow}";'
                            then:
                              - script.execute: cycle_steps_5cycle_pre_upflow # fill/service/brine/backwash/rinse    
                            else:
                              - if:
                                  condition:
                                    lambda: 'return id(clack_select_cycle).state == "${clack_pre_fill_upflow_2}";'
                                  then:
                                    - script.execute: cycle_steps_5cycle_pre_upflow_2 # fill/service/brine/rinse/backwash    
                                  else:
                                    - if:
                                        condition:
                                          lambda: 'return id(clack_select_cycle).state == "${clack_post_fill_no_2nd_backwash}";'
                                        then:
                                          - script.execute: cycle_steps_4cycle_post # backwash/brine/rinse/fill    
                                        else:
                                          - if:
                                              condition:
                                                lambda: 'return id(clack_select_cycle).state == "${clack_post_fill_2nd_backwash}";'
                                              then:
                                                - script.execute: cycle_steps_5cycle_post  # backwash/brine/backwash2/rinse/fill

interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: |-
              return id(start_time) != 0;
          then:
            - lambda: |- 
                id(run_time) = id(sntp_time).now().timestamp - id(start_time);
            - component.update: timer1
          else:
            - lambda: |-
                id(run_time) = 0;
      - if:
          condition:
            lambda: |-
              return id(start_time_total) != 0;
          then:
            - lambda: |- 
                id(run_time_total) = id(sntp_time).now().timestamp - id(start_time_total);
            - component.update: timer2
          else:
            - lambda: |-
                id(run_time_total) = 0;

binary_sensor:
  - platform: template
    name: ${clack_motor_running}
    id: bin_sens_motor_run
    internal: false
    lambda: |-
      if (id(motor_run)) {
        return true;
      } else {
        return false;
      }

  - platform: template
    name: ${clack_water_flowing}
    id: clack_water_flowing
    lambda: |-
      return (id(clack_flow_rate).state > 0);
    on_state:
      - if:
          condition:
            binary_sensor.is_on: clack_water_flowing
          then:
            - script.execute: check_leakage

  - platform: template
    name: ${clack_water_leakage}
    icon: mdi:home-flood
    id: clack_water_leakage
    lambda: |-
      return id(leakage_detected);

###  ESP restart button
button:
  - platform: restart
    id: restart_button
    name: ${clack_restart}

###  ESP restart (safe mode) button
  - platform: safe_mode
    id: safe_mode_button
    name: ${clack_safe_mode}

####################################test
  - platform: template
    name: ${clack_test_motor_run}
    id: test_motor_run
    on_press:
      then:
        - script.execute: clack_motor_run  #give pulse when motor runs to different step.
        - if:
            condition:
              lambda: 'return id(wait_on_delay) == false;'
            then:
              - script.execute: decide_cycle #choose what regeneration cycle to run

#-----------
#SENSORS
#-----------
sensor:
  ##
  # Power meter - ch1- clack pcb / ch2- Atom s3 lite esp / ch3- chlorinator
  - platform: ina3221
    address: 0x41  #A0-VCC
    channel_1:
      shunt_resistance: 0.1 ohm
      power:
        id: ch1_power
        name: ch1_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - or:
            - delta: 0.4
            - median:
                window_size: 7
                send_every: 4
                send_first_at: 3
          - round: 1
        on_value:
          - component.update: clack_power  #template sensor
        on_value_range:
          - above: 1.2  #setting was 1.0 for WS1. But to low for CE because of LCD screen power consumption
            then:
              - script.execute: decide_cycle  #choose what regeneration cycle to run
      bus_voltage:
        id: ch1_voltage #Voltage ch1 - 2 - 3 are the same
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          then:
            - component.update: clack_voltage  #template sensor

    channel_2:
      shunt_resistance: 0.1 ohm
      power:
        id: ch2_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.1
          - round: 1
        on_value:
          - component.update: clack_power_esp  #template sensor

    channel_3:
      shunt_resistance: 0.1 ohm
      power:
        id: ch3_power
        internal: true
        filters:
          - lambda: |-
              if (isnan(x)) {
                return 0;
              } else {
                return x;
              }
          - median:
              window_size: 7
              send_every: 4
              send_first_at: 3
          - delta: 0.2
          - round: 1
        on_value:
          - component.update: clack_power_chlorinator  #template sensor          
    update_interval: 1s

  ##
  # TOF distance sensor.
  - platform: template
    name: clack_distance #${clack_distance}
    id:  clack_distance
    unit_of_measurement: cm
    accuracy_decimals: 1
    icon: "mdi:arrow-expand-vertical"
    device_class: distance
    state_class: measurement
    internal: true
    on_value:
      then:
        - globals.set:
            id: last_distance
            value: !lambda |-
              const float old_distance = id(last_distance); 
              const float new_distance = id(distance_cm).state;
              if (new_distance > old_distance) {
                return id(clack_distance).state;
              } else {
                return old_distance;
              }
        - sensor.template.publish:
            id: last_distance_cm
            state: !lambda |-
              return id(last_distance);
        - script.execute: recalculate

  - platform: template
    id: last_distance_cm
    name: ${clack_distance}
    icon: mdi:arrow-expand-vertical
    unit_of_measurement: cm
    accuracy_decimals: 1
    device_class: distance
    state_class: measurement
    update_interval: never

  - platform: template
    id: clack_voltage
    name: ${clack_voltage}
    icon: mdi:lightning-bolt
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_voltage).state;

  - platform: template
    id: clack_power
    name: ${clack_power}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch1_power).state;

  - platform: template
    id: clack_power_esp
    name: ${clack_power_esp}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch2_power).state;

  - platform: template
    id: clack_power_chlorinator
    name: ${clack_power_chlorinator}
    icon: mdi:flash
    unit_of_measurement: W
    accuracy_decimals: 1
    device_class: power
    state_class: measurement
    update_interval: never
    lambda: |-
      return id(ch3_power).state;

  ##
  # ultrasonic distance sensor calculate tank_percentage
  - platform: template
    id: clack_procent
    name: ${clack_procent}
    unit_of_measurement: "%"
    accuracy_decimals: 0
    icon: "mdi:percent-box-outline"
    update_interval: ${tank_percentage_update_interval}
    state_class: measurement
    filters:
    - lambda: |-
        if (x >= 100) return 100.0;
        else if (x <= 0.0) return 0.0;
        else return x;
  ##
  # Saltlevel animation picture on dashboard
  - platform: copy
    source_id: clack_procent
    id: clack_salt_level
    name: ${clack_animation}
    filters:
    - lambda: |-
        if (x >= 80) return 100;
        else if (x >= 65 && x <= 79) return 80;
        else if (x >= 40 && x <= 64) return 60;
        else if (x >= 20 && x <= 39) return 40;
        else if (x >= 10 && x <= 19) return 20;
        else if (x >= 5 && x <= 9) return 10;
        else if (x <= 4) return 0;
        else return x;

  ##
  # TOF distance sensor calculate salt level from bottom
  - platform: template
    id: clack_height
    name: ${clack_height}
    unit_of_measurement: cm
    accuracy_decimals: 1
    icon: "mdi:hydraulic-oil-level"
    update_interval: ${clack_height_update_interval}
    device_class: distance
    state_class: measurement
    filters:
    - lambda: |-
        if (x >= 100) return 100.0;
        else if (x <= 0.0) return 0.0;
        else return x;

#------
# CLACK
#------
#  Watermeter
  - platform: template
    id: clack_m3_left
    name: ${clack_m3_left}
    unit_of_measurement: m³
    device_class: water
    state_class: total
    accuracy_decimals: 2
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;

  - platform: template
    id: clack_l_left
    name: ${clack_l_left}
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x <= 0) return 0;
        return x;

  - platform: template
    id: clack_percent_l_left
    name: ${clack_percent_l_left}
    icon: mdi:water-percent
    unit_of_measurement: "%"
    device_class: water
    state_class: measurement
    accuracy_decimals: 1
    update_interval: ${watermeter_update_interval}
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;

  - platform: template
    id: clack_percent_time_left
    name: ${clack_percent_time_left}
    icon: mdi:progress-clock
    unit_of_measurement: "%"
    device_class: duration
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 600s
    lambda: |-
      if(id(regen_last) == 0){
        return 0;
      }
      float resthours = (id(regen_last) - id(sntp_time).now().timestamp) / 3600 + (id(clack_capacity_days).state * 24);
      float capdays = id(clack_capacity_days).state * 24;
      float procent = (resthours / capdays) *100;
      return procent;
    filters:
    - lambda: |-
        if (x >= 100) return 100;
        else if (x <= 0) return 0;
        else return x;


  - platform: template
    name: ${clack_save_total_liters_used}
    id: clack_save_total_liters_used
    icon: mdi:water-check-outline
    unit_of_measurement: L
    device_class: water
    state_class: total
    accuracy_decimals: 1
    update_interval: never
    lambda: |-
      return id(save_total_liters_used);

  - platform: template
    name: clack_brine_time
    id: clack_brine_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_brine_time);
    on_value:
      then:
        - component.update: clack_brine_time_txt

  - platform: template
    name: clack_backwash_time
    id: clack_backwash_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash_time);
    on_value:
      then:
        - component.update: clack_backwash_time_txt

  - platform: template
    name: clack_backwash2_time
    id: clack_backwash2_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_backwash2_time);
    on_value:
      then:
        - component.update: clack_backwash2_time_txt

  - platform: template
    name: clack_rinse_time
    id: clack_rinse_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_rinse_time);
    on_value:
      then:
        - component.update: clack_rinse_time_txt

  - platform: template
    name: clack_fill_time
    id: clack_fill_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_fill_time);
    on_value:
      then:
        - component.update: clack_fill_time_txt

  - platform: template
    name: clack_service_time
    id: clack_service_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_service_time);
    on_value:
      then:
        - component.update: clack_service_time_txt

  - platform: template
    name: clack_total_run_time
    id: clack_total_run_time
    icon: mdi:clock-check-outline
    accuracy_decimals: 0
    update_interval: never
    internal: true
    lambda: |-
      return id(save_total_run_time);
    on_value:
      then:
        - component.update: clack_total_run_time_txt

  - platform: internal_temperature
    name: "Internal Temperature"  

select:
  - id: clack_select_chl_or_dpsw
    name: ${clack_select_chl_or_dpsw}
    platform: template
    options:
      - ${clack_off}
      - ${clack_chlorinator}
      - ${clack_dp_sw_init_regen}
      - ${clack_dp_sw_hold_regen}
    initial_option: ${clack_off}
    optimistic: true
    restore_value: true
    entity_category: config
    update_interval: never

  - id: clack_select_cycle
    name: ${clack_regeneration_mode}
    platform: template
    options:
      - ${clack_post_fill_no_2nd_backwash}
      - ${clack_post_fill_2nd_backwash}
      - ${clack_pre_fill_upflow}
      - ${clack_pre_fill_upflow_2}
      - ${clack_pre_fill_no_2nd_backwash}
      - ${clack_pre_fill_2nd_backwash}
    initial_option: ${clack_post_fill_no_2nd_backwash}
    optimistic: true
    restore_value: true
    entity_category: config
    update_interval: never
    on_value:
      - text_sensor.template.publish:
          id: clack_all_cycle_steps
          state: !lambda |-
            if(id(clack_select_cycle).state == "${clack_post_fill_no_2nd_backwash}")
              return { "${clack_post_fill_no_2nd_backwash_steps}" };
            else if(id(clack_select_cycle).state == "${clack_post_fill_2nd_backwash}")
              return { "${clack_post_fill_2nd_backwash_steps}" };
            else if(id(clack_select_cycle).state == "${clack_pre_fill_upflow}")
              return { "${clack_pre_fill_upflow_steps}" };
            else if(id(clack_select_cycle).state == "${clack_pre_fill_upflow_2}")
              return { "${clack_pre_fill_upflow_2_steps}" };
            else if(id(clack_select_cycle).state == "${clack_pre_fill_no_2nd_backwash}")
              return { "${clack_pre_fill_no_2nd_backwash_steps}" };
            else if(id(clack_select_cycle).state == "${clack_pre_fill_2nd_backwash}")
              return { "${clack_pre_fill_2nd_backwash_steps}" };
            else
              return { "" };
##
# Text sensors with general information.
text_sensor:
# Textsensor "clack_all_cycle_steps"
  - platform: template
    name: ${clack_cycle_steps}
    id: clack_all_cycle_steps
    icon: mdi:basket-fill
    update_interval: never
  ##
  # Expose ESPHome version as sensor.
  - platform: version
    id: clack_version
    name: ${clack_version}
    hide_timestamp: true

  ##
  # Expose WiFi information as sensors.
  - platform: wifi_info
    ip_address:
      name: ${clack_ip}
      icon: mdi:ip-network

  ##
  # Textsensor "Fill Salt" yes or no.
  - platform: template
    name: ${clack_fill_salt}
    id: clack_fill_salt
    icon: mdi:basket-fill
    update_interval: never

  # Textsensor "cycle_step"
  - platform: template
    name: ${clack_cycle_step}
    id: clack_cycle_step
    icon: mdi:basket-fill
    update_interval: never

  - platform: template
    name: ${clack_time_to_regen}
    id: time_to
    icon: mdi:clock-outline
    update_interval: 600s
    lambda: |-
      char str[32];
      int64_t regen_last_time = id(regen_last);
      int64_t current_time = id(sntp_time).now().timestamp;

      if (regen_last_time == 0) {
        return {"Unknown"};
      }

      int64_t total_hours = (regen_last_time - current_time) / 3600 + (id(clack_capacity_days).state * 24);
      int days = total_hours / 24;
      int hours = total_hours % 24;

      if (days > 0) {
        sprintf(str, "%id %ih", days, hours);
      } else {
        sprintf(str, "%ih", hours);
      }
      return {str};

  - platform: template
    name: ${clack_save_total_time_used}
    id: clack_save_total_time_used
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      return id(save_total_time_used);

#  - platform: template
#    name: ${clack_time_to_resinclean}
#    id: time_to_resinclean
#    icon: mdi:bacteria-outline
#    update_interval: 600s
#    lambda: |-
#      char str[32];
#      if(id(resinclean_last) == 0){
#        return {"Unknown"};
#      }
#      int hours = (id(resinclean_last) - id(sntp_time).now().timestamp) / 3600 + (id(resinclean_capacity_days).state * 24);
#      int days = hours / 24;
#      hours %= 24;
#      if( days > 0){
#        sprintf(str, "%id %ih", days, hours);
#      }
#      else{
#        sprintf(str, "%ih", hours);
#      }
#      return { str };

  - platform: template
    name: ${clack_cycle_runtime}
    id: timer1
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(run_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_cycle_total_runtime}
    id: timer2
    icon: mdi:clock-start
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(run_time_total);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

#
## saved times previous cycle to formatted text.
  - platform: template
    name: ${clack_brine_time_txt}
    id: clack_brine_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_brine_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_backwash_time_txt}
    id: clack_backwash_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_backwash_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_backwash2_time_txt}
    id: clack_backwash2_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_backwash2_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_rinse_time_txt}
    id: clack_rinse_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_rinse_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_fill_time_txt}
    id: clack_fill_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_fill_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_service_time_txt}
    id: clack_service_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_service_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

  - platform: template
    name: ${clack_total_run_time_txt}
    id: clack_total_run_time_txt
    icon: mdi:clock-check-outline
    update_interval: never
    lambda: |-
      char str[32];
      int sec = id(save_total_run_time);
      int min = sec / 60;
      int hrs = sec / 3600;
      sec %= 60;
      min %= 60;
      if( hrs > 0){
        sprintf(str, "%ih %im %is", hrs, min, sec);
      return { str };      
      }
      if( min > 0){
          sprintf(str, "%im %is", min, sec);
      }
      else{
        sprintf(str, "%is", sec);
      }
      return { str };

##
# imput numbers as sliders for setting the dimensions of the tank and level alarm.
number:
  ##
  # Set pulse per liters flowmeter
  - platform: template
    id: clack_set_pulse_per_liters
    name: ${clack_set_pulse_per_liters}
    icon: mdi:pulse
    optimistic: true
    mode: box
    step: 0.05
    entity_category: config
    min_value: 0
    max_value: 50
    initial_value: 16.8
    restore_value: yes
    unit_of_measurement: " "
    on_value:
      then:
        - globals.set:
            id: pulse_per_liter
            value: !lambda |-
              return id(clack_set_pulse_per_liters).state;

  ##
  # Set minimum distance (from bottom sensor / above plastic cap)
  - platform: template
    id: clack_saltlevel_height_min
    name: ${clack_saltlevel_height_min}
    icon: mdi:toggle-switch-variant
    optimistic: true
    mode: slider
    step: 0.5
    entity_category: config
    min_value: 0
    max_value: 10
    initial_value: 0
    restore_value: yes
    unit_of_measurement: cm
    on_value:
      then:
        - script.execute: recalculate

  ##
  # Set maximum distance (from bottom sensor / underneath plastic cap) to water level (to measure in pipe?)
  - platform: template
    id: clack_saltlevel_height_max
    name: ${clack_saltlevel_height_max}
    icon: mdi:toggle-switch-variant-off
    optimistic: true
    mode: slider
    step: 0.5
    entity_category: config
    min_value: 0
    max_value: 100
    initial_value: 30
    restore_value: yes
    unit_of_measurement: cm
    on_value:
      then:
        - script.execute: recalculate
  ##
  # Set alarm level
  - platform: template
    id: clack_saltlevel_height_fill
    name: ${clack_saltlevel_height_fill}
    icon: mdi:hydraulic-oil-temperature
    optimistic: true
    mode: slider
    step: 0.1
    entity_category: config
    min_value: 0
    max_value: 25
    initial_value: 1.5
    restore_value: yes
    unit_of_measurement: cm
    update_interval: 600s
    on_value:
      then:
        - text_sensor.template.publish:
            id: clack_fill_salt
            state: !lambda |-
              if (id(clack_height).state < id(clack_saltlevel_height_fill).state) {
                return {"${clack_yes}"};
              } else {
                return {"${clack_no}"};
              }
  ##
  # Set capacity liters
  - platform: template
    id: clack_capacity_liters
    name: ${clack_capacity_liters}
    icon: mdi:water-opacity
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 20000
    initial_value: 18600
    restore_value: yes
    unit_of_measurement: L
    on_value:
      then:
        - pulse_meter.set_total_pulses:
            id: clack_flow_rate
            value: !lambda |-
              return id(totalWaterUsage) * id(pulse_per_liter);

  ##
  # Set capacity days
  - platform: template
    id: clack_capacity_days
    name: ${clack_capacity_days}
    icon: mdi:calendar-clock
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 28
    initial_value: 14
    restore_value: yes
    unit_of_measurement: ${days}
    on_value: 
      then:
        - component.update: time_to
        - component.update: clack_percent_time_left
  ##
  # Set resinclean capacity days
 # - platform: template
 #   id: resinclean_capacity_days
 #   name: ${clack_resinclean_capacity_days}
 #   icon: mdi:calendar-clock
 #   optimistic: true
 #   mode: slider
 #   step: 1
 #   entity_category: config
 #   min_value: 0
 #   max_value: 365
 #   initial_value: 120
 #   restore_value: yes
 #   unit_of_measurement: ${days}
 #   on_value:
 #     then:
 #       - component.update: time_to_resinclean
  ##
  # Set chlorinator relay off-delay
  - platform: template
    id: clack_chlorinator_delay
    name: ${clack_chlorinator_delay}
    icon: mdi:toggle-switch-variant
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 45
    initial_value: 10
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - globals.set:
            id: duration
            value: !lambda 'return int(x);'

  ##
  # Set minimum time delay for leakage alarm
  - platform: template
    id: clack_leakage_alarm_delay
    name: ${clack_leakage_alarm_delay}
    icon: mdi:home-flood
    optimistic: true
    mode: slider
    step: 1
    entity_category: config
    min_value: 0
    max_value: 60
    initial_value: 30
    restore_value: yes
    unit_of_measurement: "min"
    on_value:
      then:
        - globals.set:
            id: duration_leakage
            value: !lambda 'return int(x);'

  ##
  # Set minimum time delay for considering water flow stopped
  - platform: template
    id: clack_water_flow_timeout_delay
    name: ${clack_water_flow_timeout_delay}
    icon: mdi:waves-arrow-right
    optimistic: true
    mode: box
    step: 0.1
    entity_category: config
    min_value: 0
    max_value: 300
    initial_value: 6.5
    restore_value: yes
    unit_of_measurement: "s"
    on_value:
      then:
        - globals.set:
            id: duration_water_flow_timeout
            value: !lambda 'return float(x);'
        - lambda: !lambda |-
            id(clack_flow_rate).set_timeout_us(uint32_t(id(duration_water_flow_timeout) * 1000000UL));
